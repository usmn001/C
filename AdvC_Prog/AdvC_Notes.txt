----------------------------------------------Advance C Programming Course----------------------------------------------------

In C we can disintegrate a very large program into multiple files of code instead of keeping a signle source 
code file which is difficult to be updated and maintained.

This approach of breaking a lerger program into groups of multiple files is called modular approach offering
benefits such as : 

Teams of programmers can work on different sections or parts of a program for e.g. one developer will be developing
UART interface code and another for SPI and another working on main embedded application thus allowing a highly 
parallelized approach to development enabling all the codes to be combined by using header files through
#include preprocessor directive. Moreover we can also link different source code files through object files 
by using gcc or clang compiler or anyother again we will need to include the relevant header files into our main 
source code i.e. 

gcc -c -o main.o main.c
gcc -c -o func_obj.o func_src.c   function object file is generated from it´s source code.
gcc -o  main main.o func_obj.o    main source code and function object files are linked to form a single executable.

Another way to link a submodule/function object file with our main source code and generate executable code  is to compile and link

gcc (-compilation flags or options -Wall,-std,-Wextra -fmax-errors) func_obj.o main_src.c -o main_execfile

Where -std flag defines which version of C language we want to compile in this case it´s c11 so we make -std=c11
      -Wall flag is used to turn on additional warnings about potential bad code practices.
      -Wextra flag is used to turn on more warnings than the -Wall flag alone will activate.
      -fmax-errors=10 flags indicates listing of maximum of 10 errors
      -o option flag sets the compiler optimiztion level


Normally this approach of combining and linking multiple object files of sub modules works well however if we have numerous ones then we can merge them
into a library file which can be linked either statically or dynamically with main source code file , it should be noted that 
each static and dynamic linking have it´s own advantages and disadvantages alongwith specific syntax to be used with relevant compiler.

-------Communication Between Two Files-------------

Two or more files containing code can pass information either through function methods and through extern variables
(a extension of global variables) while in case of function menthods it should be noted that we include respective 
header files in a program file from where a specific function is called thus arguments can be passed
and returned for e.g. 

main.c : #include <stdlib.h>
         #include "sum.h"
         void main(void) {
         uint8_t a ;
         uint8_t b ;
                        
         b=sum(a,b);
         }   
 
sum.c : int sum(uint8_t sa,uint8_t sb) 
        {   
         return sa+sb;
        }

sum.h : int sum(uint8_t,uint8_t);

Normally when we have multiple modules then we have function definitions of each module in .c file and 
function prototypes in .h file enabling us just to attach each module .h header file in our main source code 
file.

If we are using compiler from command line then we need to make sure that we compile all the multiple module 
files correctly such that relevant object codes are generated and linked with main source code file smoothly.

To use external variables in our sorce code files we use the keyword extern with global variable and it becomes
accessible in all of our program files provided that it´s also defined in all of the module files with same 
definiton.


For example : 

main.c : #include <stdlib.h>
         extern int num=0;
         void main(void){
         
         num +=1;
 
         }

mod.c :  extern int num;
         void mod { 
         num = num*2 
         }

Or 

main.c : #include <stdlib.h>
         extern int num;
         void main(void){
         
         num +=1;
 
         }

mod.c :  extern int num =2;
         void mod { 
         num = num*2 
         }

Notice here we can access num extern variable outside of our files in both scenarios.


-----static global variable--------

If we want a global variable to be only accessed inisde one specific source code file then we use static keyword with it at the time of it´s
declaration, this is very useful if we want to avoid repeatitive decalarition error. Static is just the opposite of extern.

To do it just write  : 

static int num = 1;

For example : 

main.c : #include <stdlib.h>
         static int num = 1;
         void main(void){
         
         num +=1;
 
         }

mod.c : #include <stdlib.h>
        int num =2;
        void mod() {
        num = num *2;  
}


Notice here that both global variables have same names but they cannot be outside of both files. 

------Enum (Enumeration)----------

It´s a user defined data type in C allowing us to assign names to integers thus improving program readablity. For example : 

enum Week {Mon, Tue, Wed, Thu, Fri, Sat,Sun};

Now to utilize the above enumeration definition in our program we do 


enum Week Day;

Day = Wed;

printf(" Today is %i nd day of the week",Day);  Output : Today is 2nd day of the week 

When we have multiple enumeration then the constants present in all must be unique in their names otherwise compilation error will be generated.


             ------------Mmeory Types Available To Us In C-----------


There are three types of memory available to us i.e. Static, Stack and Heap.


Static memory persists throguh entire lifecycle of our program used to store global variables or variables 
declared with static cluase.

----------Stack Memory-------

Managed By the CPU.

All local variables of a function are placed in stack, these variables are pushed onto the stack as long 
as the function is in exection after that they are popped out of the stack and no longer exists.

Stack memory shrinks and expands as variables get created in a function as discussed earlier why it happens.

Stack memory is limited in size if we push to much variables on it then it overflows occuring mostly 
in recursion case.

Stack memory is divided into successive frames each time when a function is called it allocates itself a fresh 
stack frame.

Stack has fast access time as compared to heap.

Use stack when we have small variables.

Stack cannot be resized i.e. we cannot assign more mory to local variables once they are pushed on the stack.

---------Heap Memory---------

Not Managed CPU but by the programmer.

Opposite of stack.

Large pool of memory used dynamically.

Accessed by pointers.

Allocate memory through malloc() and deallocates through free() , failure to deallocate memory results in
memory leaks i.e. same heap memory cannot be used by other processes and part of our program.

Heap can be accessed anywhere in the program through the use of pointers.

Global varfaibles are placed in heap memory.

Heap is used when we need to store large block of data such as large data structure or big array.

and also if we have some global variable which we want to keep for longer period of time.

Allocated Heap memory can also be resized using realloc().


--------------------------------------------------------------------------Section 5:Storage Classes In C------------------------------------------------------------------

Storage classes in C determine scope, visibility and lifetime of a variable existing in a memory enabling us to trace it´s existence while a program 
executies.

By scope of a variable we mean from where it can be referenced or accessed in a program like for example some varaibes are global and some are local.

Visbility or linkage of a variable determines in case of a multiple source file program whether identifier is known only in current source file or in any source file with proper declarations.

By default all local variables have auto storage class as they exists only inisde body of a function or Block of code (inside a conditionla statement ) and get´s destroyed when we step out of a function or block of code.

C Provides following four storage classes :
auto
register
extern
static

These storage classes are split further into automatic storage duration and static storage duration.

Storage class of a variable is specified as : storage_class data_type variable_name;

------- Auto storage class----

In auto storage class we have automatic storage duration i.e. here variables are created and destroyed 
automatically. Auto storage class variables are created when we enter a block of memory where they are defined is entered, These variables exist while the block is active and destroyed when we exit the block.

By default All local variables in C are automatically managed and are of auto storage class. 
These local variables exist when we enter a function where they are defined and we exit a function they are destroyed and this process repeats whenever we enter and exit a function.

In C++ auto keyword has a different use rather than using it for storage class.

------------extern storage class----------

extern storage class allows us to access and modify global variables outside of a source code file.
If we have defined a global variable in one file for e.g. in main.c then we don´t need to define it again in 
second source file for e.g. sec_code.c , Consider the following example

In main .c code file : 

int num =1;
int main() {


}

In sec_code.c : 
extern int num;     // This informs the compiler that num is defined somewhere else and now both source code files
                // can access and modify variable values same hlds true for arrays and structures and data types.
int func() {


}

Example : Using extern with arrays

main .c : 
int num_arr[30];
int main() {
return 0;
}

sec_code .c : 
extern int num_arr[];
int num() {
return 0;
}
 
However when we´ve multiple dimmensional arrays then we may need to specify second dimmension in sec_code.c file
can´t leave it blank.


--extern specifier on functions----

Normally when a function we can call a function from outside of a source code file by just including the header
file where it´s declared but when we use extern keyword with it then we don´t need to use header files where
it´s declared


main.c : 
int count;
extern void add();
int main()
{
add();
} 

sec_code.c : 
extern int count ;
void add(){
count +=1;
}


So it means in order to bring scope and visibility of a variable , array , function from a code file where it´s defined to a source code file where we want to access or reference it then we use extern keyword with it.

-----static storage class---------

static is opposite of extern.

When we have static local variables then their values remain same during entire execution of program. No new
memory get´s allocated in case of static local variables unlike automatic local variables. syntax of defining
static local variable is : static data_type var_name ; 

When we have static global variables then those global variables can´t be accessed outside of a program source code file.

Static variables are allocated memory on heap not on stack.

Static functions can be called only from within same source file where they are defined. Syntax : 
static return_type func_name(data_type arguments){

}

Example : static local variables
static int a = 1;
main.c : int main()
{
a+=1;    // Here value of a variable a will remain same no matter how many times it get´s called, variable a will be initialized from it´s last value.
printf("Value of a %i",a);
return 0;
}

-----static and structures------

static variables should not be declared inside a structure as C compiler requires entire structure elements placed together.

It is possible to declare a strucutre : 
 Inside a function (stack segment)
 allocate memory dynamically (heap segmnet)
 it can even be global.

The value for structure element is fetched by counting the offset of the element from beginning address of
structure.

Separating out one memebr alone to a data segment defeats the purpose of a static variable.

It is possible to have an entire structure as static.

------register storage class------

register storage class is used to define local variables that should be stored in a CPU register instead of RAM memory, we do this when want to access a particular value of variable very fast as we know CPU registers are the
fastest memory.

register storage class is used with variables that are most frequently used in a C program.

it´s the compiler choice to put a variable in a register or not. 

lifetime of a register variable remains only within block of code.

we cannot obtain address of a register variable using pointers i.e. it cannot have unary &operator applied to it.
as registers don´t have memory addresses.

register storage class variables can only be local i.e. they can only exist in a function.

Syntax of using register storage class is : register data_type var_name

-------------------------------------------------------------------Section 6: Advanced Data Types-----------------------------------------------------------------------

#define is a pre processor directive used to assign names,symbols to different values. for e.g :

#define PI 3.14
#define PI ss

Te typedef keyword is used to assign names to existing data types present in C for e.g. 
typedef int jj;
jj a is equivalent to int a;

typedef int* i_ptr;
typedef struct {
  int code;
  char name[]; 
}state;

typedef is handled by compiler.

use typedef for the data types used for arrays,structs, pointers and functions.
use typedefs for portable types i.e.
  when we need a data type of at least 20 bytes then we make it a typedef.
  when we port the code to different platforms then we need to select right type i.e. short,int,long so instead
  of changing the data types everywhere in the program due to change in architecture we just change the datatype
  in typdef statement i.e. typedef int aa;  new--> typedef long aa; 


------Variable Length Arrays---------

Arrays where we define the size of array at compile time instead of making it constant, normally user or some
other part of program will define the size of array. for e.g.

size_t arr_sz;
scanf("%i",&arr_sz);

C11 compiler does not provide support for variable lenght arrays because it is an optional feature, to check support we use the preprocessor directive ifdef as : 
#ifdef __STDC_NO_VLA__
 printf("Variable length arrays are not supported.\n");

Instead of using variable length arrays it´s preferred to use heap memory where we can use pointers.

Moreover instead of using character arrays for storing strings we can also use character pointers for e.g.
char ptr* = "Hello World"  instead of char arr[] = "Hello World";

In this case char ptr*  compiler allocates 12 consecutive bytes for string literal "Hello World" and 4 extra bytes for pointer variable ptr. And assigns the address of the string literal to ptr. So, in this case, a total of 16 bytes are allocated.

In case char arr[]  compiler allocates 12 consecutive bytes of memory and associates the address of the first allocated byte with arr.

-----Flexible array members-----

flexible array memeber is a feature introduced in the C99 standard of the C programming language, it allows us to
declare an array without any dimmension and whose size is flexible in nature and flexible array members size is
variable(can be changed at run time)

struct s{
int arraysize;
int array[];
}; 

so if weant to allocate memory on heap for the above struct then we do 
int main(){
struct s *ptr;    
int des_size = 5;
ptr = (struct)malloc(sizeof(struct s) + des_size * sizeof(int) ); // where des_szie is providing dimmensions of array
}

A flexible array member can be declared only a last member of a struct.
Each struct can contain at most one flexible array member.

A flexible array cannot be the only member of a struct, struct must also have one or more fixed members.

Any struct containing a flexible array member cannot be a member of another struct.

A struct with flexible array member cannot be statically initialized, it must be allocated dynamically.

A struct with a flexible array member reduces number of allocations for by 1/2.
 instead of 2 allocations for one struct object you just need 1. 
    meaning less effort and less memory occupied.
    save the storage for one additional pointer.

----------------Complex number types----------

complex numbers like this : a+bi ; where a is eal part and b with i is imaginary part. (bi means b*i)

In c to use complex numbersin our code we first need to include header file 
complex.h in our code and then we can use functions 

--complex functions----
creal() for getting real part of a value of type double complex passed as argument.
cimag() for getting imaginary part of a value.

we append an f to thee function names when we are working with float complex values i.e. crealf() and cimagf().
similarly l when working with long double complex values i.e. creall() and cimagl().

conj() function for returns complex conjugate of it´s double complex argument.
we use conjf() and conjl() functions for returning complex conjugate for other two complex types as mentioned earlier.

-----Creating comlex numbers----

#include <complex.h>

#define __STDC_WANT_LIB_EXT1__1

int main() {

#ifdef __STDC_NO_COMPLEX__                           // Checking if complex numbers are supported or not
 printf ("Complex numbers are not supported. \n");
#else
 printf("Complex numbers are supported.\n");

double complex cx = 1.0 + 3.0*I; // here cx is variable name and double is data type of complex variable.
double complex cy = 1.0 - 4.0*I;
double complex 

printf("Complex number values are : cx = %.2f%+.2fi  cy = %.2f%+.2fi\n", creal(cx), cimag(cx),creal(cy),cimag(cy) );

// to add the two complex numbers we do similarly we can perform other operations that is *,/,- 
double complex sum = cx + cy ;

// to take conjugate of a complex number we do
double complex conjugate = conj(cx);
printf("\n The conjugate of cx = %.2f%+.2fi \n",creal(conjugate),cimag(conjugate));

double complex c = 3.0 + 2.0 *I;
double complex pwr = cpow(a,c);
printf("a ^ b is : %f + %fi \n ",creal(pwr), cimag(pwr));

#endif
  
}

-------Designated Initializers---------

Designated initializers allows us to assign initialization values to elements of array,structure or union either
these values are following an array index or a field by name (struct and union).

c90 standard requires elements of an initializer in fixed order.
c99 standard requires us to initialize elements in random

Initializing array elements : 
int a[6] = { [4]=29, [2]=1};   //Here array 4th element is assigned value 29 and 2 index has value 1

For initializing a range of array indexes or elements we can do [first...last] = value for e.g.
int a[] = {[0..9]=1,[10.99]=2};


If we want to intialize a structure memebrs then we can do : 

struct point{
int x,y,z;
};

int main(){
struct point p1 = {.x=1, .y=2, .z=3};
// For an array of structures we do
struct point pts[5] = { [2].y=5, [2].x =6; [0].x=2 }   
// here [2].x means that we have assigned pts[2].x=6 and pts[0].x =2 where pts[2] is our pointer to 2nd struct and pts[0] is pointer to 1st struct
return 0;
}


------------------------------------------Section : 7 Type Qualifiers-------------------------

Type qualifiers are used with variables data types giving the compiler more information about intended use of
variables thus they perform compiler optimization leading to less execution time of code and e.t.c.
In C99 we´ve three type qualifiers : const , volatile and restrict 

-----const qualifier--------
const qualifier variables (incl.arrays,structs) have fixed values , assigned values cannot be changed during program run time.
const qualifier also enables us to make addresses assigned to pointers fixed similarly to case of variables.
const qualifier enables us to place variable in read only memory .

Syntax : const data_type variable_name

Example : const int a =1;
          const int grades[5] = {0,1,2,3,4};
          const struct country{
              char name[];
              int area;
          };

In case of pointers we can do
const data_type *ptr;         // Value pointed by pointer address remain constant this can also be written as 
                              // data_type const *ptr;
data_type * const ptr;        // Address of pointer remains constant
const data_type * const ptr ; // Value pointed out by pointer and Pointer Address both remain constant.  

We can use constant with global variables in order to avoid variable syncronization
In ANSI C standard if a pointer is used only to give access to a function values then that pointer needs to be declared with const qualifier for e.g. : void display(const int array[],int limit)

Library function strcat also uses const i.e. char *strcat(char *restrict s1, const char * restrict s2); // Here second paramter will remain constant only first get´s modified that´s why it´s not with const qualifier.

we can also put const qualfier static storage variables in a header file and share them among source code files.

If we analyze differences between const and define then we find : 
#define a pre processor directive can be used anywhere in a program and it´s not scope controlled unlike
const which is scope controlled and needs to be used in a function.

---------volatile type qualifier------------

this qualifier informs compiler explicitly that specific variable will change it value therefore compiler
get´s prevented from caching it.

volatile type quailifier is mainly used in cases of real timeand embedded systems programming where their´s
 a lot of threading and programs resources are scarce.

Hence we can say that variable should be declared volatile when it´s value could change unexpectedly.

Noramlly three types of variables use volatile
             . Memory mapped peripheral registers.
             . global variables (non stack variables) modified by an interrupt service routine.
             . global variables accessed by multiple tasks within a multi threaded application.

Syntax : volatile data_type loc1;  // loc1 is a volatile location, where loc1 holds a volatile value
         volatile data_type *ploc; // ploc pointer points to a location holding a volatile value 

Example 1 : val1 = x;
          /******* 
               code doing something 

            ****/
           val2 = x;       
         
           Smart optimizing compiler notices that we are using x twice without changing it´s value
           and would temporarily store the value of x in cpu register and when it´s value is needed for
           val2 it will just fetch it from COU register instead of it´s original memory location.
       
    So this above optimization is not required if x is changed between two statements by some other agency
    and we would use volatile keyword to ensure that compiler doesnot optmize and instead has a stored value
    for each variable that´s why we use volatile keyword in order to prevent this optimization.


Example 2 : We´´ve a ouput port pointed out by a pointer *outPort and we are writing two letters to it for e.g.
            *outPort = ´O´;
           /******* 
               code doing something 

            ****/
            *outPort = ´N´;
           Now a smart compiler will notice these successuive assignments to the same memory location and in case
           if outPort is not modified in between then the comiler would have removed the first assignment from the
           program and placed the value pointed out by it in CPU register so next time if it get´s changed then
          it will provide it to us from cpu register instead of the newest one.

          To prevent this we use volatile type qualifier i.e. volatile char *outPort;

We can also use volatile with const when we want one entity to be not modified by any code section of program however we want it to be modifiable by any external agency outside of the program that can be a thread or other process.

For e.g. volatile const int loc or const volatile int *ploc; // both have effect

---------restrict type qualifier-----------

Restrict type qualifier is used in pointer declarations informing the compiler that : 
             Value pointed out pointer is not refeenced by other pointers or variables within the scope.
             The pointer is the only one providing access to the pointed value.
     Compiler does not need to add any additional checks and free to look for computational shortcuts.
If both restric and volatile qualifiers are used then result is indefined behavior.

Compiler can choose to ignore restrict type qualifier as it´s just a optimization hint to it.

C++ also does not support it.

Syntax : data_type *restrict ptr_name 
    
Example 1 : int main(void) {
    int array [10]; 
    int * restrict restar = (int *) malloc(10*sizeof(int));
    int *par = array;
    for(int i=0; i<10 ; i++) {
    par[i] +=5;    
    restar[i] +=5;
    array[i] *=2;
    par[i] +=3;
    restar[i] += 3;     // The compiler will now optimize the statements with restar pointer and will comibine 
                           them to restar[i] +=8;
    }
}

In C library we´ve two functions memcpy and memmove where restric qualifier is used i.e.
void * memcpy(void * restrict s1, const void * restrict s2, size_t n);  // Here s2 is the only pointer pointing to  const value of void data type i.e. at the passing pointer address it will be defined here void is used so all data type values can be passed to it.
void * memmove(void * s1,const void * s2,size_t n);


-----------------------------Section 8 : Bit Manipulation---------------------------------------

conversion of a -ive decimal number : 
add 1 to decimal number.
express the -ive value in binary
take 1s complement

conversion of -ive binary number back to decimal
take 1s complemment
convert binary number to decimal
change sign of result
subtract 1


data_type variable : number_of_bits_assigned ;


------------------------------Section 9 : Advanced Control Flow--------------------------------

-------goto statement----------
goto statment causes program control to jump to a particular line of code in our program.
To identify where in the program the jump needs to be made, a label is needed. 
Label needs to be placed directly before the statement to which jump is to be made and must appear in 
the same function as goto.

Syntax : 
label : statement
goto label;




------null statement-----
null statement is useful when syntax of language calls for a statement but no expression evaluation.

Examples : while((*text++=getchar())!='\n')
;
Here in above example we are using null statement denoted by ; informing compiler that statement following 
looping expression is not inside the body of loop without null statement ; the compiler will be considering the
preceding statment as part of while loop.

 
--------comma operator--------

comma , operator acts like a binary operator evaluating first operand and discarding the result, then evaluates
the second operand and returns it´s value and type because all operators in C produce a value, value of
comma operator is that of rightmost expression.

comma (,) operator allows us to separate multiple expressions anywhere inside a valid program starement.

Example : int main() {
         while(i<100)
          sum+= data[i], ++i;  // here first array data index i value is assigned and incremented to sum and then 
                               // index of array is incremented 

         int i(5,10);  // here i is assigned value 10
         x = (y=3, (z= ++y +2) + 5);   // here first value of y = 3 is assigned to x 
                                       // then value of z = 11 gets assigned to x
         int houseprice = 249,500;     //Here similarly first 249 will be assigned then value 500 will be assigned
                                       //to variable houseprice       

 return 1;

}

------------------------------Section 10 : Input and Output----------------------------

Originally, input/output functions were not part of the definition of C.
  . Their development was left to C implementations.
  . Unix implementation of C has served as a model for these functions.

When a C program is executed, following three files are automatically are opened by the system for use by the
program i.e. stdin, stdout and stderr (defined in <stdio.h>) that´s why we include this file for i/o operations.

    .stdin identifies the standard input of the program and is normally associated with your terminal window.
      .all standard I/O functions that perform input and  do not take a FILE pointer as an argument get their
       input from stdin.
      .stdout refers to standard output, which is normally associated with our terminal window.
      .stderr identifies standard error file where most of the error messages produced by the system are written
       and is also normally associated with our terminal window. 


------Char Input Functions-----------

getc function : used to read a single character from a file or from user input provided through standard terminal.

syntax : getc(FILE *fp); return _type : ASCII integer value, when returns EOF it means End of file.
         getc(stdin);    here we are taking input from the user in terminal.

Example : 
int main(){
char ch = '\0';
if(fp=fopen("user.txt","rw)!=NULL){
while(ch!=EOF){
ch = getc(fp);
}
}

}
   
getchar function : reads only input characters from standard input terminal
Syntax : printf("%c\n",getchar());
Example : 
int main() {
int ch = 0;
while ((ch = getchar())!=EOF)
printf("%c\n",getchar());
return 0;
}// the above program break it´s execution when we hit ctrl + d.

fgetc() : function used to read character from file using , file pointer.

Example : 
int main(){
FILE *fp;
fp = fopen("src.c","r");

while(1){
  c=fgetc(fp);
  if(c==EOF)
   break;
  printf( "%c",c);
}

printf("Closing the file test.c");
fclose(fp);
return 0;
}

ungetc() : function that returns back the character read from input stream.
syntax : ungetc(ch,stdin) or ungetc(ch,FILE *fp);
Example : 
int main(){
char ch = 0;
while(isspace(ch = (char)getchar()));
ungetc(ch,stdin);

printf( "char is %c\n",getchar());
return 0;
}

---------Char Output Functions-----------

putc() : function writes a single character to a file (or to stdout).
         File needs to opened in write or append mode.
Syntax : putc(char var_name, FILE *fp);

putchar() : function writes a single character to standard output(stdout) i.e. terminal
Syntax : putchar(int ch); where ch is a unsigned character.
Example : putchar('C'); 
Example : 
int main() {

char string [] = "Hello Usman and Mehwish";
int i=0;

while ( string[i] !=0) {

if(string[i] != '\n') {
   putchar(string[i]);
  ++i;
}

}


fputc : Function writes a character to a output file or to standard out tetminal window, 
        it increments the current write position of character in both file and output window. 

--------string functions---------

---input---

gets() : Function used to read line of strings from input to a buffer until a terminating newline or end of file
         (EOF) character is found thus causing buffer overflow.
         Takes one input argument which is a pointer to an array of chars where string is stored.
         returns str on success and NULL on error or when end of file occurs.

Definition : char *gets(char *str)

This function is deprecated and should never be used, it´s removed from C11 instead use fgets() or getchar()

fgets() : Function retains newline character (\n) unlike gets. It terminates reading a string input when
          newline character offer protection against buffer overflow problem.
          
          When a null character \0 is present in the string it cannot detect it and will be stored in the input
          buffer with the rest of characters thus this is a problem leading to the conclusion that fgets()
          should only be used when data read cannot contain a null character therefore use getline function
          to avoid this problem.

Definition : char *fgets(char *buffer,int n,FILE *stream) 
             Where : 
             buffer  a pointer to character array where line that is read will be stored.
             n  denotes maximum number of characters that can be stored in the buffer including null character.
             stream is a file pointer or standard input. (stdin).
Example : 

#include<stdio.h>
#include <string.h>

int main()
{
char buff[255];
int ch = '\0';
char *p = NULL;

if (fgets(buf,sizeof(buf),stdin)) {
p=strchr(buf, '\n');
if (p) {
*p= '\0';
}
else {
while (((ch = getchar()) != '\n') && !feof(stdin) && !ferror(stdin) );
}

}

Note : feof(FILE *fp) or feof(stdin) functions are used to detect end of file or of input , functions 
       ferror(FILE *fp) or ferror(stdin) detects error in file stream or in the input stream.

       char *strchr(const char *str, int c) function searches for a particluar character in the string pointed out
       by char *str pointer which is character array or string literal pointed out by a pointer.


getline() : This is a Latest function for reading a entire line of string from a stream ,introduced around 2010.
            Preferred over gets,fgets and scanf input functions which are all unreliable.
            Reads an entire line up to and including next newline character and takes three parameters.

Syntax : ssize_t getline(char **buffer,size_t *size,FILE *stream)
         
        Where 1st parameter is a double pointer to a block of memory allocated by malloc or calloc thus
         it can automatically enlarge block of memory as needed by using realloc as heap memory is dynamic.
         1st paramter contains the line read from last paramter  FILE stream pointer.
         2nd paramter determines the size of memory pointed out by 1st paramter, it´s actually a pointer 
         pointing to a memory location where value of allocated memory size is present.  

        return type : is -1 when error occurs or end of file is reached without reading any bytes.   
                      returns number of characters read including the newline but not final null character).

Example : int main()
{ 
char *buffer = NULL;
size_t bufsize = 32;
size_t characters;

buffer = (char*)malloc(bufsize *sizeof(char));

if(buffer == NULL) {
exit(1);
}
printf("Type something : ");
characters = getline(&buffer,&bufsize,stdin);

printf("%zu characters were read . \n",characters);
printf( "You typed : '%s' \n ",buffer);
return 0;
}

---output----

puts : used to write a line to oputput screen similar to printf.
definition : int puts(const char *string). 

fputs : function to write string on a file .
defintion : int fputs(const char *buffer, FILE *fp);


 --------------Formatting Functions----------------

                                      
        
sprintf() : Behaves exactly same like printf().
fprintf() : writes data to a file and can also write error messages to stderr stream for e.g.

           if((inFile=fopen("data","r"))==NULL)
             {
            fprintf(stderr,"Can´t open data for reading .\n");
             ...
              }
fscanf() : used to write data on a file similar to fwrite().
sscanf() : used to read formatted data from a string rather than standard input or keyboard.
           syntax : int sscanf(const char *str,const char *contro[arg_1,arg_2,...]);
           example : sscanf(buffer,"%s %d",name,&age); // reading data from pointer buffer and placing
                                                          according to specified format in name variable
                                                          and age pointer         

rewind() : function used to set position of file in the begining through file pointer provided by fopen() .
fflush() : function used to flush/clean a file or buffer, causes any unwritten data in output buffer
           to be sent to the output file this process is called flushing.
   
      
----------------------------------------Section 11: Advanced Function Concepts------------------------

-----------Variadic Functions--------------

Variadic functions are used to take varying number of inputted arguments unlike normal functions having a fixed number of arguments . printf() is a variadic function as we can pass any number of arguments to it. Similar to
printf we can also create our own functions that will be able to get varying number of arguments.

A variadic function has two parts : 
   .Mandatory arguments : where at least one is required and is first one listed normally this first argument
                          informs the variadic function how many arguments are being passed it´sa good practice
                          enabling us to limit a operation performed inside variadic function for a fixed number
                          of iterations.

To reference the varying number of arguments we use macros defined in stdarg.h header file. These are follows and
also used in creating a variadic function 

va_list() : used in situations where we need access to optional parameters and it is an argument list.
            represents data object holding parameters corresponding to ellipsis (...) part of the parameter list.

va_start() : connect our argument list with argument pointer
             list specified in va_list is first argument and second argument is last fixed paramter.

va_arg()   : will fetch current argument connected to argument list however we also need to provide
             datatype of argument we are reading.

va_end()   : used when we want to stop reading and using variable argument list.

va_copy()  : used for saving our current location.
              
1 .First we create a function prototype with ellipsis .... with a return type as : 
void f1(int n,...) or int f2(const char*s,int k,...); 

2. Create a va_list type variable in the function definition and initialize it to an argument list i.e.
double average (double a1, double a2,...){

va_list parg;   // Where parg is pointer for variable argument list.

va_start(parg, a2)   // Specifying parg to point to the first variable argument passed to the function when it is
                     // called
}

3. access the contents of argument list using : va_arg(parg,data_type), va_arg() returns first item when it is
                                                called for first time and returns second one when it is called 2nd
                                                time and so on till nth argument.
4. clean up using va_end() i.e va_end(parg);

 
Example : 

double average(double v1,...) {
va_list parg;
double sum = v1 + v2;
double value = 0.0;
int cnt = v1;
va_start(parg,v2);

while((value = va_arg(parg,double)) != 0.0) {
  sum += value;
  ++cnt;
} 
va_end(parg);

return sum;
}


int sum(int v1,...) {
va_list parg;
int val = 0,sum = 0,cnt = 0;
va_start(parg,v1);
while(cnt<v1){                    // Using first argument as a limiter.
        val = va_arg(parg,int);
	sum +=val;
        cnt+=1;
}
va_end(parg);

return sum;
}


int main(void)

{
double v1,v2;
printf("\n Using variadic function Sum = %i",sum(2,2,4));
printf("\n Average = %.2lf",average(v1,3.5,v2,4.5,0.0));
}

In summary variadic function should have at least one fixed paramter.
We should have a way to detect which data type is passed for that we can have a paramter in the varadic function.
    
--------------va_copy-------------

This macro enables us to cmake a copy of variable argument list. Syntax : va_copy(args1,args2); or va_copy(parg1,parg2).     Here argument list pointed out by second paramters args2 or parg2 gets copid into the 
                          first ones i.e. arg1 or parg1.   

Example : 

int add(int a,...) {
va_list args1;
va_start(args1,a);
/*****Some codes for logic operation
int val1= va_arg(args1,int); 
***************/

va_list args2;
va_copy(args2,args1);
va_start(args2,a)
/************Some codes for logic operation
int val2 = va_arg(args2,int);
*********/

return val1;
}



}
                   
---------------Recursion----------------


In recursion a function calls itself continously until a certain condition is met. We can also implement
recursion using loops.

Example : Fictorial Calculation Function

int factorial (int n){

if(n==0)
 result =1;
else
  result = n * factorial(n-1);
return result;
}

void main() {
int num = 0;
for( num = 0; num <8; num++)
{
printf("%d!= %d),num, factorial(num));

Iteration terminates when loop continuation condition fails.
Recursion terminates when a base case is recognized.
Iteration keeps on modifying(increment/decrement) loop counter variable until a certain defined termiation value is reached where loop ends.
Recursion keeps producing simpler versions of original problem until base case is reached.

Avoid using recursion if performance is a metric as it consumes a lot of resources CPU and stack.


----------in line Function--------

C99 introdunced this concept of inline functions.

inlining a function is a compiler optimization technique in which a suggestion is provided to compiler thus that
the compiler will normally go for placing the entire code of function being called in the function that is caller
instead of going through the entire process of passing arguments, jumping to function code and returning and
context switching.

The compiler can choose to ignore inline declaration of a function or compiler chooses to perform some other sort of optimization.

inline fuctions may improve performance of code however it´s not guaranteed.

inlning a fucntion requires more memory space as instead of calling a function a copy of it is placed in the caller again and again.

It´s preferred to do inlning on short and frequently called functions.

To make a fucntion inline just use inline keyword along with static storaage class specifier with it´s declaration and definition for e.g.

inline static void sum(int a);

inline static void sum(int a) {
// do some operations
return 0;
}


To share inline function amoong multiple files we can place it´s definition in a header file, this is a exception
only applicable to inline function because inline functions has internal linkage so its multiple definitions 
in several files does not cause problems.

---------_Noreturn Functions----------

C11 added a second function specifier (in addition to inlne) function.

The specifier _Noreturn informs the user that and compiler that specific function will not be returning control
to the calling program when it completes execution.

_Noreturn function just like inline specifier is a hint to the compiler and the compiler
can opt to ignore it.

Using _Noreturn function specifier does not stop a function from returning to its caller.

Only a promise made by programmer to compiler allow it some more degree of freedom to generate optmized code. 

exit() function is an example of _Noreturn function.

_Noreturn is different from void functions.

When a function specified with _Noreturn specifier violates its promise and returns
to it´s caller(by using an explicit return statement or by reaching end of function body the
our program code behavior becomes : 
      .Undefined
      . We should try our best to avoid returning from that function.

Compilers are not required to produce warnings or errors when _Noreturn function appears
to be capable of returning to its caller. 

How _Noreturn is used : 

_Noreturn keyword appears in a function declaration.
This specifier _Noreturn may appear more than once in same function declaration however it will be counted still one time.

_Noretun specifier is typically used through convenience macro noreturn and it´s provided in header file <stdnoreturn.h>

Use of _Noretun or noreturn is equivalent. 

Syntax : _Noreturn or noreturn void function_name() {

         
          }   // we will not use return statement but at end of function we need to use exit() or abort().

Example 1 : When using noreturn

#include <stdio.h>
#include <stdlib.h>
#include <stdnoreturn.h>


noreturn void my_exit(void);

/* calls exit() and doesn´t return to its caller ¨*/

void my_exit(void){
printf("Exiting...\n");
exit(0);
}

int main(void){
my_exit();
return 0;
}

Example 2 : Using _Noreturn

#inlcude <stdio.h>
£inlcude <stdlib.h>

_Noreturn void foo() {
abort();
}

int main (void) {
printf("Ready \n ");
foo();
return 0;
}

-----------------------------------Section 12 : Union---------------------------------

Union is similar to structure. 

In Union all memebers reside in same memory space unlike structures. Size of this allocatedmemory is equal to the size of largest member residing in union.

We need to make sure that data in union is referenced with relevant data type, referencing data in a union
with a variable of wrong type is a logic error.

Operations that can be performed on a union are : 
 Assigning a union to another union of same type.
 Taking address of a union variable.
 Accessing union members.

Some use cases of union are representing a file containing different record types and a network interface 
containing different request types.

We use union when our construct can be of many different things i.e. objects but only one at a time.

In union only first member can be initialized and only one member can be accessed at a time.

---------Defining a Union---------

union [union tag]{
type_1 identifier1;
type_2 identifier2;
....
....
type_N identifier_N;
}optional_variable_definitions;

Union tag is optional and each member definition is a normal variable definition.

At the end of union definition before final semicolon we can specify one ormore union variables but its optional.

Union definition is placed in a header file just like strucutres if we weant to share it among several files.

Example 1 : union Data {
          int i; 
          float f;
          char str[20];
          }data; 

Mmeory is allocated by compiler when we create variables to access it i.e. union Data d1 . where d1 is variable. and in the above example data also is.

structures and arrays both can contain unions.

pointers to unions can also be declared just like the same way we do with strcutres.

Anonymous union does not have any name and it can only be created inside a structure.

Example 2 : Anonymous union in a structure

struct {
  
  char *name;
  enum symbolType type;
 union {
   int i;
   float f;
   char c;
} data;

}table;

The above example is an array of structures, where entries variable defined somewhere.



Example 3 : In the following example we have a anonymous union

struct car_data{
   char make[15];
   int status;
   union {
   struct owner owncar;
   struct leasecompany leasecar;
        };
};

----------Accessing a Union--------------

Unions are accessed just like structures with a dot notation . using variable and with -> nusing pointers.

We can also initialized a union member using a . notation for e.g. 

union number {
int i;
float f;
double aa;
} 

void main(){
union number n1 = {.i = 0,f = 1.1, aa = 22.2234};
}



----------------------------------------Section 13 : The Preprocessor------------------------------------------

A C program passes through following stages before becoming a executable. 
Preprocessor
Compilation : Produces Assembly language equivalent code.
Assembler : Produces Object Code. 
Linker : Comibines object files into a single machine executable file.
Loader : Executable file loads into memory.

Preprocessor not a part of C compier is invoked before compiler, performing following three main tasks : 

Removal of all comments.
Includes the source code of the header files in the main program wherever the #include directive is used.
Expand Macro definitions ( Macros are small functions).

------------Conditional Compilation----------

Conditional Compilation is a feature offered by C preprocessor enables us to 

Create a program that can be compiled to run on different computer systems (varyng architecture and OS´s).

It is also used to turn on and off various debugging statements and for tracing flow of program execution.

Condtional compilation also allows us to control execution of preprocessor directives and compilation of 
program code by : 
     Evaluation of each conditional preprocessor directive against an identifier or constant integer 
     expression.
     Cast expressions, sizeof expressions and enumeration constants cannot be evaluated  in preprocessor
     directives.

Conditional compilation commands are : #if , #endif (for ending #if block), #ifdef, #ifndef, #elif and #else , They are totally similar to if , else if , else , #if defined(name) and if !defined(name) 


------#ifdef----
This directive checks whether a identifier is defined or not using #define directive (#define identfier val or #define identifier) . Some compilers also allows us to define an identifier using -D option at compile time in terminal i.e. 
gcc -D UNIX program.c

Syntax : #ifdef identifier

         #endif

Where as mentioned earlier #endif ends the scope of preprocessor directives : #if,#ifdef,#ifndef,#else,#elif. 

------#ifndef--------
Directive checks if an identifier is undefined , it´s just the opposite of #ifdef, it´s often used to define a identifier which is previously not defined in conjunction with #define directive for e.g.

#ifndef SIZE
 #define SIZE 100
#endif

-------#if-------

We use #if directive to test the value of a constant expression specified by #define statement or thorugh command line using -D option.

Syntax : #if constant_expression 

The constant expression if it´s integer cannot contain any increment(++),decrement(--),sizeof,pointer(*),address(&) and cast operators.

Just like if statement we can also use relational and logical operators with #if directive

Example : 

#include <stdio.h>

#define MYDEF 5
#define MYOTHERDEF 2

int main(void) {

#if MYDEF == 5 && MYOTHERDEF == 2
 printf("Hello");
#endif

return 0;
}

---------#else---------

#else directive works exactly the same way as else statement in case of if .
This directive identifies a group of directives or statements execution in case when #if , #ifdef, #ifndef conditions fails.

Example : 

#ifdef UNIX
#define DATADIR "/uxn1/data"
#else
#define DATADIR "\usr\data"
#endif

we can also define DATADIR at command line during compilation i.e. gcc -D DATADIR=/c/my_data

-------------#elif---------------

Directive is used for multiple choice statements, similar to elseif statement.

Syntax : #elif constant_expression (with relational and logical operators)

-----------include guards and #undef---------

The include guards make sure that a header file is not repeatedly inlcluded in a source code file.
Standard C header files use the #ifndef technique to avoid multiple inclusions. 
Make sure that the indetifier being tested should not be defined elsewhere among the source code files.

Example : 
#ifndef THINGS_H_
 #define THINGS_H_
  /* rest of include file */
#endif

---------#undef--------

Directive let´s us to undefine a directive previoulsy defined identifier.

syntax : #undef identifer 

---------------#pragma and #error------------------


------#pragma--------

#pragma directive lets us to place compiler instructions in our source code.

#pragmas are used : 
 To control amount of memory set aside for automatic variables.
 Set strictness of error checking.
 Enable nonstandard language features.

pragma standing for (pragmatic  information)directive depends upon software implementation of standard thus every compiler has it´s own set of pragmas thus to use pragmas we may need check documentation
of a specific compiler.

Syntax : #pragma token_name
  Where token_name represents a command for the compiler to obey.

We will be studying following pragmas supported by gcc compiler.
   #pragma GCC dependency
   #pragma GCC poison
   #pragma GCC system_header
   #pragma once
   #pragma GCC warning
   #pragma GCC error
   #pragma message

#pragma GCC dependency : Directive allows us to check relative dates of current file and another file.
                         If the other file is more recent than current file then a warning is issued.
                         Here by current file we mean where the source file where this pragma is used.
                         Example : #pragma GCC dependency "parse.y"
                                   #pragma GCC dependency "/usr/include/time.h" rerrun fixincludes (this is a warning message)

#pragma GCC poison : Directive used to completely remove an identifier from the program, if any of the
                     identifier is completely removed and then it appears again in the program then a 
                     error is displayed by the compiler.
    Example : #pragma GCC poison printf sprintf fprintf (removing identifiers printf sprintf fprintf)
              sprintf(some_string,"hello"); // Now it will be producing a error

#pragma GCC system_header : Directive tells the compiler that the code after this directive to be
                            considered as system header (files that come with OS).
                            code that comes before #pragma in the field is not affected. 
                            All warnings get suppressed while GCC is processing a system header.
                            Macros defined in a system header are immune to a few warnings wherever 
                            they are expanded.

#pragma once : Just like include gurards instructs the compiler to incude header file only once but this
               directive offers less portability so include gurads should be used for this purpose.  

#pragma GCC warning "message" : causes the pre processor to issue a warning diagnostic message with the
                                text "message". This message should be a string literal.

#pragma GCC error "message" : causes pre processor to issue an error with text message, again text in
                               message should be string literal  
  
#pragma message "message"   : prints string as a compiler message on compilation (information message).  


-------#error----------

Preprocessor directive causing the preprocessor directive to issue an error message including any text in the directive. Error message is a squence of characters separated by spaces, we don´t need to enclose this text in quotes and this is a optional message.

Example : #if __STDC_VERSION__!=201112L  // should fail if compiler used is an older standard and succeed
          #error Not C11                 // when it uses c11 
          #endif


Some other directives are #warning, #line linenum, #line linenum filename

-----------------------------------Section 14 : Macros-----------------------------------------


Macros are similar to functions except they are created using #define pre processor directive.

Syntax : #define MACRO macro_body
            where  MACRO represents the macro name
                   macro_body is replacement list or body which will replace the section of code where
                   macro is called as this replacement is done by preprocessor

Example 1 : #define PX printf("x is %d.\n",x)
                   where PX is macro name 
                         printf statement is macro body

Capital letters should be used for macro names.           
Macros run until first newline following the #. 
Use continuation operator \ for expanding macro body to more lines.
If macro is based upon expression then everything after #define directive is considered as macro body.

Example 2 : 

#include <stdio.h>

#define PI 3.14       // This is a symbolic constant macro
#define PRNT(a,b)\
        printf("val 1 = %d\n",a);\
        printf("val 2 = %d\n",b);

int main(){
int x =2;
int y =3;
PRNT(x,y); // now when code is pre processed, the line where macro is invoked pre processor replaces 
           // this statment with printf statements
}

 
 macro inside a nested loop is a much better candidate for speed improvements, we can use program profilers to know where our program is spending most time.

Macros don´t have to worry about variable types unlike functions.

As macros are at pre processor level so it´s not possible to debug them so what can we do is use
gcc -E source_file.c command in in termial so our compiler gcc expands everything to us.

inline functions are the best alternate to macros however as inline keyword is just a hint to compiler
it´s not a strict rule while macros don´t.

Example : Function Macros

#include <stdio.h>
#define PI 3.14
#define CIRCLE_AREA(x) ( (PI) * (x) * (x))

int main(){
int area = CIRCLE_AREA(4);  // Now this text will be replaced by ((PI) * (x) *(x))
printf(" Area is %d\n",area);
}

We can also have variadic macros 

Example : Variadic Macros 

#include <stdio.h>
#define Warning(...) fprintf(stderr,__VA_ARGS__)

int main() {
Warning ("%s : this is here \n","jason")
return 0;
}


Examples : 
#include <stdio.h>
#define FOO BAR
#define BAR(12)
#define MISC(x) (puts("incrementing",(x)++)
#define Max(a,b) ((a) > (b) ? (a) : (b))


-------Preprocessor Operators-------------

# and ## operators are used for concatenation, it is useful to merge two tokens into one while
expanding macros, called token pasting or token concatenation.

# operator is used within a macro definition

## operator performs token pasting 
   concatenates two tokens
   when a macro is expanded two tokens on either side of each ## operator are combined
   into a single token.

\ operator is used for expanding macros.

defined() operator : It´s used in constant expressions to determine if an identifier is defined using #define directive or not, it´s similar to #ifdef.

   If specified identifier is defined then it´s evaluated to true(non zero)
   If identifier is not defined then it evaluates to false.(zero).

Example : #if defined (DEBUG)
          // program statements
          #endif

Example : 

#if defined (WINDOWS) || (WINDOWSNT)
# define BOOT_DRIVE "C:/"
#else
#define BOOT_DRIVE "D:/"
#endif

int main(void) {
printf( "Here is boot drive path : %s\n",BOOT_DRIVE);
return 0;
}

Above will display as output "C:/" if either WINDOWS or WINDOWSNT is defined
     .output will be "D:/" otherwise

This use of pre processor operator with #if is similar to if else if statements.


-------#operator-------

# operator creates a constant string out of macro argument and places double quotes around macro argument.

Example 1 : 
#define str(x) #x
str(testing) // This line replaced by macro as "testing".

so if we do printf(str(Programming in C is fun.\n)) then it becomes printf("Programming in C is fun.\n").

Example 2: 
#define HELLO(x) printf("Hello,"#x"\n");
when HELLO(john) appears then macro expands to printf("Hello, John\n");

-------##operator------------

Operator used in macro definitions to jon two tokens together.
  Preceded or followed by name of a paramter to macro.
  Takes actual argument to macro supplied when macro is invoked and creates a single token out of
  argument and whatever toekn follows (or precedes the) ##.

Examples : 

#define make_function(name) int my_##name(int foo){}
when we call this macro as make_function(bar) // where we are passing bar as argument to macro make_fucntion then here on the line where macro is invoked preprocessor pastes int my_bar(iny foo)

#define eat(what) puts ("i am eating "  #what "today")

when invoked as eat(fruit) results into puts("i am eating" "fruit" "today"); interprested as single string constant.

-------------Pre defined Macros------------

standard C provides predefined symbolic constants
  begin and end with two underscores.
  They cannot be used with #define or #undef directives

These standard predefined preprocessing macros are specific to a compiler so we should consult
their documentation as well.

.___FILE___ : Macro represent current file name(string).

.__LINE__   : Macro represent current line number of current source code (integer constant).

.__func__   : Macro provides name of any function when placed inside a function of current file.

.__DATE__ : Macro provies the date when source file was compiled in form of string("MMM dd yyyy" such as 
            "Jan 19 2002" )
.__TIME__ : Macro provides the time whens ource file was compiled (a string literal of the form
            "hh:mm:ss")

.__STDC__ : used to indicate if compiler suports standard C by returnig value 1.

Example : #include <stdio.h>
int main(void) {
#if(__STDC__==1) 
 printf("Implementation is ISO-conforming.\n");
#else
 printf("Implementation is not ISO-conforming.\n");
#endif
return 0;
}


__FILE__and__LINE__ : __FILE__ macro represents name of current source file as string literal comprising
                               entire file path i.e. "C:\\Projects\\Test\\MyFile.c"

                     __LLINE__ macro results in an integer constant corresponding to currentl line
                               number
so that´s file why we can use both of these macro in combination inside our program for debugging purposes as well for tracking in which file error has occurred and at what line.

Example : 
if(fopen(&pfile,filename,"rb"))   {
fprintf(stderr,@Faild to open file in %s line and %d \n",__FILE__,__LINE__);
return -1;
}
so if fopen fails then there will be a message specifying source file name and the soure file linenumber where the error has occured thus we don´t need to use printf statement.

------------------Section 15 : Advanced Debugging,Analysis and Compiler Options----------------------

---------GCC Compiler Options----------

When we invoke gcc, it normally performs preprocessing,compilation,assembling and linking.

We use gcc compilation flags for getting debugging and other information.

gcc -E src_file.c > file     : For visualizing preprocessng stage output.   

gcc -save -temps src_file.c  : provides us all the intermediate files (.i file at preprocssing level,.s
                               file for assembly code) used during the process of generating
                               a signle executable file.

gcc -Wall -ansi src_file.c :    makes sure that we are complying ansi standard if not it generates
                                warnings.

gcc -Wall -funsigned-char src_file.c : if we want to consider char data type as unsigned.

gcc -Wall -fsigned-char src_file.c : If we want to consider char data type as signed.

gcc -g src_file.c : For generating debugging information.

Compiler optimization flags allow compiler to improve performance and /or code size at the expense of increased compilation time and possibly effecting the debugging ability of program.

We can invoke gcc with -Q --help=optimizers to find exact set of optimzations enabled or disabled.

Some levels of optmizations are : -O, -O1, -O2, -O3, -Ofast,-Og

------------GCC Environment Variables-----------

PATH : For searching executables and run time shared libraries.(.dll,.so)
CPATH : For searching include-paths for headers.
        searched after paths specified in -l<dir> options.
        C_INCLUDE_PATH  can be used to specify C headers if specific langage was indiacted 
        in pre processing.

LIBRARY_PATH : For searching library-paths for link libraries.
               Searched after paths specified in -L<dir> options.

ldd : utility examining executable and displaying a list of shared libraries required.
      Syntax : ldd a.out or ldd ./a.out where a.out is executable.

nm : utility used for viewing functions defined in a object file. where under T column we have functions
     defined. 'U' column where functions are undefined.     

-----------Debugging With Preprocessor--------------

By using a preprocessor identifier we can use inserted debugging code in our program, and also enable or
disbale this debugging by checking whether or not the preprocessor identifier is defined or not using
#ifdef.

Example : 
#define DEBUG

int process (int i, int j, int k) {
return i+j+k;
}

int main(void) {
int i,j,k, nread;
nread = scanf("%d %d %d",&i, &j,&k);

#ifdef DEBUG
 fprintf(stderr,"Number of integers read = %i\n",nread);
 fprintf(stderr, "i = %i, j = %i, k= %i\n",i,j,k);
#endif 

printf("%d\n",process(i,j,k));
return 0;
}

----------Debugging With GDB Debugger------------

GDB Debugger commands that we can use are : 

gdb executable_name : starts gdb debugger in terminal
list : command shows code.
list line_num : shows code before 5 lines and after 5 llines from specified line number.
set var variable_name = value : command allows us to assign values to specific variable used in code.
print variable_name : gdb command shows variable assigned value.

For specific variables local to a function just include function name in above commands after the variable_name  i.e. gdb_command function::variable_name and similarly you can assign values to relevant
variables.



infor source : provides us information about source code file currently being under debugging.
break line_num : puts break point at specified line number.
break func_name : put break point in the start of function.
break src_file.c :func_name : put break point at specific fucntion present in src_file.c

run : command runs program in gdb debugger after we have placed break points.
c : continue command which moves the program forward after break point is encontered.
info break : lists all the breakpoints
clear : command disables all break points.
clear line_num : disables beak points at line number.
clear function : disables break point in function.


-------------core files-------------

Core files are generated by core dump when a program crashes or is terminated abnormally due to segmentation.

Segemenation fault occurs when we try to access memory restrcited to us.

Core dump is also called memory or storage dump.

Core files contain a snapshot of contents of the process memory at the time when program got terminated thus these core files can be used for debugging purposes more specifically tracing what went wrong during program execution similar to white and black box recording technique.

Core dumps cann also be used for capturing data during dynamic memory allocation.

A core dump is contained in a file named simlar to core.<process_id>

On some systems core dump may be disabled due to large size of the core files which we can enable using ulimit -c unlimited command.

For viewing core dump files we will need to use a debugger allowing us to 
  examine state of process.
  include listing stack traces for all threads of the process.
  we can also print the values of variables and registers.

we will also need to add debugging information to executable by gcc-g.

----steps,commands for viewing core file------

In windows using cygwin : 
gcc -g src_file.c
gdb exec_file.exe exec_file.exe.stackdump

In linux

gdb ./src_file.out core : command for starting analysis of core file using debugger
info locals : command for visualizing the variables.

-----------Profiling-----------

Profiling a program allows to measure consumption of : 
  Mmeory while it´s running.     
  Time complexity (efficiency)
  Usage of particular instructions.
  Frequency and duration of function calls.

We do profiling through a tool using either program executable or it´s source. Profiling information
serves to aid program optimization.

Profilers use a number of techniques such as event-based,statistica, instrumented and similation methods.

--------GNU Profilers gprof and valgrind--------

gprof profiler uses hybrid approach of compiler assisted instrumentation and sampling.

gprof gathers profiling information by probing program counter at regular intervals through
operating system interrupts thus resulting profiling data is not exact but statistical approximation.

gprof is more preferred in multithreaded applications.
gprof is unable to profile shared libraries used in our source code maaking it unsuitable for
today´s real world projects.

gcc -pg src.c -o exec_name .
./exec_name
gprof exec_name gmon.out > file.txt : command for running gprof profiler in linux and acquring output in
                                       file.


valgrind is also a profiler and also provides us information about memory leaks through memcheck tool.

valgrind --leak-check=yes ./exec_name

valgrind takes a lot of time to execute which is a big downsize to it however it´s very effective in detecting memory leaks.



Google also provides profiler tool gperftools which has very little runtime overhead. 
gperftool also enables us to do selective profiling of certain sections of code and also has no
problem with multi-threaded applications.

 
---------------------------Static Analysis-------------------------

Static analysis : A method of debugging program code without actually running it opposite to dynamic analysis done by profilers . This analysis is performed by an automated tool.

Software engineering and reverse engineering can be described as forms of static analysis.

Both static and dynamic analysis detects defects.

Static analysis is done between coding and unit testing.

static code analysis tools offer speed,depth and accuracy in comparison to manual code reviews and many more benefits.

Static code analysis have constraints : 
          .limited in understanding developer intent.
          .may detect a possible overflow in calculation
          .rules that are not statically enforceable as some coding rules depend upon documentation,
          .some rules are open to subjective interpretation.
          . possible defects lead to false positives and false negatives.

Many open source and propritary static code analyser tools are available such as : 

Coverity
CodeSonar integrated AI
SonarCube

---------------------Section 16 : Advanced Pointers------------------

Pointer to a Pointer is known as double pointer for e.g. 

data_type var_name = val_assigned;


data_type *ptr1_name = &var_name;
data_type **ptr2_name = &ptr1_name;


2nd way of declaring pointers is : 

data_type *ptr1_name = NULL, **ptr2_name = NULL;
ptr1_name = &var_name;
ptr2_name = &ptr1_name;   

Use cases For Double pointers : 

Biggest reason for using a double pointer is when we need to  change the value of pointer passed
to a function as the function argument.
  
If we pass a signle pointer in as argument : 
    We will be modifying local copies of pointer not original pointer in calling scope.
    With a pointer to a pointer we modify original pointer.

We use a double pointer as an argument to a function when we want to preserve memory allocation or
assignment even outside of function.

When we are passing address of a pointer to a function having a local pointer as it´s paramter then we
can change the value stored at the passed address however we cannot change the passed address inside the function.
   
Example : 

void foo(int *ptr){

int a = 5;
*ptr = a;      // As discussed above here we are modifying value stored at address passed from main
               // And now it will have effect when we execute print statement in main() unlike to
                  result produced by modifying address i.e. ptr = &a limited to only function.

               // To change passed address we need to make ptr as double pointer then we can do 
               // *ptr = &a and now printf statement in main will print 5      
}

int main(){
int *ptr = NULL;
ptr = (int *) malloc(sizeof(int));
*ptr = 10;
foo(ptr);         // When we have double pointer as paramter in foo function then we do foo(&ptr)

printf("%d\n",*ptr);
return 0;
}


---------Function Pointers--------

Functions contain addresses and thus we can use pointers to point towards them so basically function names are just like array names which contain addresses.


Pointers to functions i.e. Functions can be : 
   Passed to functions.
   Returned from functions.
   Stored in Arrays.
   Assigned to other function pointers.

A function pointer can be used direclty as we call a function using it´s name.

Function pointers don´t require us to allocate and deallocate memory.

---------Common Use of Function Pointers--------------

Function pointer can be used as an argument to another function just like we pass paramters to functions.

qsort() function from C library is designed to work with arrays of any kind as long as we tell it
what function to use to compare elements.
qsort() function takes a pointer to a function as one of it´s arguments for sorting.

We can use function pointers for processing different commands entered by user in a way that we put 
all the relevant function pointers in a lookup table and when the user enters a command then we can
match it with corresponding function pointer which can be used to invoke corresponding function to handle the particular command.

menu-driven systems use function pointers.
can be used to replace switch/if statements.
can be used to realize our own late-binding.
can be used to implement callbacks.
function pointers are useful when alternatice functions maay be used to perform simialr tasks on data.

--Syntax-- 

Like we used to do with normal pointers here in addition to just passing addresses we need to provide number and type of arguments to be supplied and type of return value to be expected.

A function as holds address of a function so it also needs to define a prototype.

Function pointers are dereferenced similar to other pointers in order to use pointed function.
   
--Declaration--  
When declaring a function pointer we provide pointed function return type and type of it´s paramters as well. i.e.

return_type (*pfunction) (paramters_data_type);

Example : int (*pfunction) (int);

--Assignment--

Assigning function address : We can assign any relevant function address returning same data type 
and with same number of paramters as they are with function pointer i.e. for e.g.

int look(int);  // look is a function with one int parameter.
pfunction = look; 


--Invocation---

we can invoke or call the function using function pointer as : 

int ret_val = ptr_function(func_paramter);

Example : 
int read(int);
int (*pread)(int);
pread = read;
int ret_val = pread(5);

-----------------Common Convention----------

As mentioned previously, function pointers can be passed as paramters in function calls and can be returned as function values, this use of function pointers as paramters provides flexibility for flexible functions and programs.

So if we use typdef keyword then it will allow us to declare function pointers more easily and they will become more readable as we can assign name to the function pointer return type i.e.

Normally we do : return_type (*func_ptr)(param_dta_type); so if we use typedef with function pointers we do : 
 
          typedef return_type (*func_ptr)(para_dta_type); // Hence we have created a new type enabling us 
to create relevant function pointers more easily instead of again and again typing the complete declaration and defining statement for e.g. 

typedef float (*fptr)(float);

fptr func1 = NULL; // where func1 is a pointer to a function returning float and have one argument of 
                      float and so on similarly we can create other function pointers easily.

Example 1 : 

int display(){
printf("\n--Displaying some texts--\n");
return 0;
}

int main() {
     
int (*func_ptr)();       

func_ptr = display;

printf("Address of func_ptr = %p ",func_ptr);

(*func_ptr)();

return 0;
}


Example 2 : Using Typedef 
int display(){
printf("\n--Displaying some texts--\n");
return 0;
}

int main() {
     
typedef int (*func_ptr)(); 

func_ptr fp1;      

fp1 = display;

printf("Address of func_ptr = %p ",func_ptr);

(*fp1)();

return 0;
}
                      
--------------Void Pointers--------------

A void pointer is a pointer that does not have any data type. A void pointer can point to any other address of memory holding containing data of any other type. For e.g.

int a = 1;
float fv = 0.0;
float *fptr;
void *ptr;

fptr = &fv;
ptr = &a;
ptr = fptr; // So we can also assign address of another pointer to void pointer easily.

To cast a void pointer into another data type we do : (data_type*)v_ptr;

-------Dereferencing A Void Pointer--------               
To dereference a void pointer we follow this approach *(data_type_casted*)v_ptr;  For e.g. in relation to above code we do : 
int a = 1;
vptr = &a;
*(int*)vptr +=1 ; Here we are dereferencing and adding 1 to void pointer value.

Void pointers used a lot in C like memory management functions malloc,memcpy,calloc e.t.c and with other functions in a way such that the function can take different types of paramters. For e.g.

void send(void *pData, int nlength);

we should avoid performing operations on void pointers without first casting them.


-----------------------Section 17: Libraries and Shared Objects-----------------------

Library is a collection (group) of header files and implementation files exposed for use by other programs.
Library function prototypes or inshort interfaces are present in header file. (shared with pther programmers besides .o object files)
Library function definitions are in .c file.

Libraries enable : SW reuse,version management, component specialization.

-------Linking-------

As we already know that Linking is process of collecting and combining multiple object files.

To make library code available to our program linker does : static linking and dynamic linking.

Static Linking : In static linking linker makes copy of all used library functions to executable file.
Dynamic Linking : Linker places name of library in binary file of executable code and linking happens when program is run and both program and library files are in memory.

  
----Static vs Dynamic Libraries Or (Static Linking Vs Dynamic Linking) In C----


Static Library or Static Linking

i).   Linker finds all used functions(sqrt(),printf() e.t.c) codes and puts them together into our single executable file.
ii).  Library files have extension .a in linux and .lib in windows.
iii). Generated Executable is a larger file and needs more storage space. 
iv).  If their is change in library file with .a extension then still executable does not automatically updated and needs to be relinked
      with library file.
v).   If library becomes incompataible then generated executable will still run unless it's not relniked with updated library file code.
vi).  Static library access is faster as compared with that of dynamic library access time. 


Dynamic Library or Dynamic LInking

i).   Linked dynamically at run time by the os,every program that accesses the library uses the same copy.
ii).  Library files  have the extension .so in linux and .dll in windows.
iii). Executable only contains the name of a link to the library.
iv).  If library file changes then executable will contain newer library file updated code. 
v).   If library file becomes incompatabile with our main source code then previously generated executable won't run.
vi).  Dynamic querying of symbols takes time so dynamic library files access is slower.


Library                               Static                                           Dynamic          

Compiled Command 	       gcc -c part1.c part1.o                          gcc -c -fpic part1.c part1.o    (fpic is compiler flag)
To Create Library             ar rcs libmylib.a part1.o part2.o               gcc -shared -o libmylib.so part1.o part2.o
Compile main program          gcc -c program.c -o program.o                   gcc -c program.c -o program.o
To link with main program     gcc -o program program.o -L. -lmylib            gcc -o program program.o -L. -lmylib
                                         or                                   Add library path to environment variable  
	                      gcc program.c libname.a -o program              export LD_LIBRARY_PATH:$PWD:$LD_LIBRARY_PATH  
	                                 or
	                   gcc (compiler-flags) program.c -L. -lmylib -o program           
	In above comparative scenarios of both static and dynamic we have assumed that library files are placed in
	the same path or folder where main program executbale is present.
	
	

libweather.a: weatherstats.o weatherio.o
        ar rcs libweather.a weatherstats.o weatherio.o


-----------------------------------------Section 20 : Data Structures----------------------------------------

We know in C language every data type (char,int,long,short,bool) has a property and it supports a set of operations (add,subtract,multiply).

An abstract data type (ADT) is a type whose behavior is defined by a set of value and a set of operations. 

ADT Only mentions what operations are to be performed but : 
   Does not show how these operations will be implemented.
   Does not specify how data will be organized into memory nor what algorithms will be used for implementing the operations.

Common abstract data types in C are : linked lists, stacks, queues.

Process of creating a new abstract data type follows a three step process : 

1. Provide an abstract description of the type´s properties and of the operations that can be performed on the type.
             .Not tied to any particular implementation.
             .Referred to as an abstract data type (ADT).

2. Develop a programming interface that implements ADT.
             .Indicates how to store data.
             .Describe a set of functions that perform desired operations.

3. Write code to imlement the interface.
   
 


--------------Linked List--------------------

Linked list is a linear data structure and it´s dynamic.
Linked lists are accessed through a pointer pointing to the first node of list.

In Linked list each node contains : data, 
                                    connection to next node in the list through next pointer, 
                                    may contain prev pointer for connection to previous node in case of a doubly linked list.

In Order to traverse a linked list we follow pointer from each node to next node.
   





  

































                         

  
 


 
                  










